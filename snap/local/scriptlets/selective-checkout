#!/usr/bin/env bash
# This scriptlet enhances the pull step that will only build
# development snapshots snaps if the latest tagged release has been
# promoted to the stable channel.  This ensures that there's always
# a revision of the stable release snap available in the edge channel
# for the publisher to promote to stable as currently the build
# infrastructure only supports build on code push (but not new tagged
# releases) at this time.
# https://forum.snapcraft.io/t/selective-checkout-check-out-the-tagged-release-revision-if-it-isnt-promoted-to-the-stable-channel/10617
# 林博仁(Buo-ren, Lin) <Buo.Ren.Lin@gmail.com> © 2018

set \
    -o errexit \
    -o errtrace \
    -o nounset \
    -o pipefail

for required_command in \
    awk \
    cut \
    sed \
    snap \
    sort \
    tail; do
    if ! command -v "${required_command}" >/dev/null; then
        printf -- \
            'Fatal: This script requires the "%s" command in your command search PATHs.\n' \
            "${required_command}" \
            >&2
        exit 1
    fi
done

vcs_detect(){
    if test $# -ne 1; then
        printf 'FATAL: %s: Parameter quantity mismatch.\n' "${FUNCNAME[0]}" >&2
        exit 1
    fi

    local source_tree_root_dir="${1}"; shift 1

    if test -e "${source_tree_root_dir}"/.git; then
        printf git
    elif test -e "${source_tree_root_dir}"/.hg; then
        printf mercurial
    elif test -e "${source_tree_root_dir}"/.svn; then
        printf subversion
    else
        printf not_found
    fi
}

# Ensure depending software is available before using them
vcs_check_runtime_dependencies(){
    if test $# -ne 1; then
        printf 'FATAL: %s: Parameter quantity mismatch.\n' "${FUNCNAME[0]}" >&2
        exit 1
    fi

    local -r source_tree_root_dir="${1}"; shift 1

    case "$(vcs_detect "${source_tree_root_dir}")" in
        git)
            if ! command -v git &>/dev/null; then
                # Markdown code markup is not Bash tilde expression
                # shellcheck disable=SC2016
                printf -- \
                    '%s: Error: `git` command not found in the command search PATHs.\n' \
                    "${FUNCNAME[0]}" \
                    >&2
                return 1
            fi
        ;;
        mercurial)
            if ! command -v hg &>/dev/null; then
                # Markdown code markup is not Bash tilde expression
                # shellcheck disable=SC2016
                printf -- \
                    '%s: Error: `hg` command not found in the command search PATHs.\n' \
                    "${FUNCNAME[0]}" \
                    >&2
                return 1
            fi
        ;;
        subversion)
            if ! command -v svn &>/dev/null; then
                # Markdown code markup is not Bash tilde expression
                # shellcheck disable=SC2016
                printf -- \
                    '%s: Error: `svn` command not found in the command search PATHs.\n' \
                    "${FUNCNAME[0]}" \
                    >&2
                return 1
            fi
        ;;
        *)
            printf -- \
                '%s: Warning: Unknown VCS type, assuming dirty.\n' \
                "${FUNCNAME[0]}" \
                >&2
            return 0
        ;;
    esac
}

vcs_is_dirty(){
    if test $# -ne 1; then
        printf 'FATAL: %s: Parameter quantity mismatch.\n' "${FUNCNAME[0]}" >&2
        exit 1
    fi

    local -r source_tree_root_dir="${1}"; shift 1

    case "$(vcs_detect "${source_tree_root_dir}")" in
        git)
            # If tracked files are modified
            # or staging area not empty
            if ! \
                git -C "${source_tree_root_dir}" diff \
                    --quiet \
                || ! \
                git -C "${source_tree_root_dir}"  diff \
                    --staged \
                    --quiet; then
                return 0
            else
                return 1
            fi
        ;;
        mercurial)
            # NOTE:
            # The existence of untracked files is not consider dirty,
            # imitating Git's `--dirty` option of the describe
            # subcommand
            if test -n "$(
                hg --cwd "${source_tree_root_dir}" status \
                    --added \
                    --deleted \
                    --modified \
                    --removed
            )"; then
                return 0
            else
                return 1
            fi
        ;;
        subversion)
            printf -- \
                '%s: Warning: Unimplemented VCS type, assuming dirty.\n' \
                "${FUNCNAME[0]}" \
                >&2
            return 0
        ;;
        *)
            printf -- \
                '%s: Warning: Unknown VCS type, assuming dirty.\n' \
                "${FUNCNAME[0]}" \
                >&2
            return 0
        ;;
    esac
}

vcs_has_release_tags() {
    if test $# -ne 2; then
        printf 'FATAL: %s: Parameter quantity mismatch.\n' "${FUNCNAME[0]}" >&2
        exit 1
    fi

    local -r source_tree_root_dir="${1}"; shift 1

    # Pattern to match a release tag, in extended regular expression(ERE)
    local -r release_tag_pattern="${1}"; shift 1

    case "$(vcs_detect "${source_tree_root_dir}")" in
        git)
            if git -C "${source_tree_root_dir}" tag \
                --list \
                | grep \
                    --extended-regexp \
                    --quiet \
                    "${release_tag_pattern}"; then
                return 0
            else
                return 1
            fi
        ;;
        mercurial)
            if hg --cwd "${source_tree_root_dir}" tags \
                | grep \
                    --extended-regexp \
                    --quiet \
                    "${release_tag_pattern}"; then
                return 0
            else
                return 1
            fi
        ;;
        subversion)
            printf -- \
                '%s: Warning: Unimplemented VCS type, assuming no release tags found.\n' \
                "${FUNCNAME[0]}" \
                >&2
            return 1
        ;;
        *)
            printf -- \
                '%s: Warning: Unknown VCS type, assuming no release tags found.\n' \
                "${FUNCNAME[0]}" \
                >&2
            return 1
        ;;
    esac
}

vcs_query_release_tags(){
    if test $# -ne 2; then
        printf 'FATAL: %s: Parameter quantity mismatch.\n' "${FUNCNAME[0]}" >&2
        exit 1
    fi

    local -r source_tree_root_dir="${1}"; shift 1

    # Pattern to match a release tag, in extended regular expression(ERE)
    local -r release_tag_pattern="${1}"; shift 1

    case "$(vcs_detect "${source_tree_root_dir}")" in
        git)
            if git -C "${source_tree_root_dir}" tag \
                --list \
                | grep \
                    --extended-regexp \
                    "${release_tag_pattern}"; then
                return 0
            else
                return 1
            fi
        ;;
        mercurial)
            if hg --cwd "${source_tree_root_dir}" tags \
                --quiet \
                | grep \
                    --extended-regexp \
                    "${release_tag_pattern}"; then
                return 0
            else
                return 1
            fi
        ;;
        subversion)
            printf -- \
                '%s: Warning: Unimplemented VCS type, assuming no release tags found.\n' \
                "${FUNCNAME[0]}" \
                >&2
            return 1
        ;;
        *)
            printf -- \
                '%s: Warning: Unknown VCS type, assuming no release tags found.\n' \
                "${FUNCNAME[0]}" \
                >&2
            return 1
        ;;
    esac
}

vcs_checkout(){
    if test $# -ne 2; then
        printf 'FATAL: %s: Parameter quantity mismatch.\n' "${FUNCNAME[0]}" >&2
        exit 1
    fi

    local -r source_tree_root_dir="${1}"; shift 1
    local -r revision_to_be_checked_out="${1}"; shift 1

    case "$(vcs_detect "${source_tree_root_dir}")" in
        git)
            git -C "${source_tree_root_dir}" checkout \
                "${revision_to_be_checked_out}"
            return 0
        ;;
        mercurial)
            hg --cwd "${source_tree_root_dir}" checkout \
                --rev "${revision_to_be_checked_out}"
            return 0
        ;;
        subversion)
            printf -- \
                '%s: Warning: Unimplemented VCS type, not doing anything.\n' \
                "${FUNCNAME[0]}" \
                >&2
            return 1
        ;;
        *)
            printf -- \
                '%s: Warning: Unknown VCS type, not doing anything.\n' \
                "${FUNCNAME[0]}" \
                >&2
            return 1
        ;;
    esac
}

vcs_describe_revision(){
    if test $# -ne 1; then
        printf 'FATAL: %s: Parameter quantity mismatch.\n' "${FUNCNAME[0]}" >&2
        exit 1
    fi

    local -r source_tree_root_dir="${1}"; shift 1

    case "$(vcs_detect "${source_tree_root_dir}")" in
        git)
            git describe \
                --always \
                --dirty \
                --tags
            return 0
        ;;
        mercurial)
            hg --cwd "${source_tree_root_dir}" log \
                --rev . \
                --template "{latesttag}{sub('^-0-.*', '', '-{latesttagdistance}-m{shortest(node, 7)}')}"
            return 0
        ;;
        subversion)
            printf -- \
                '%s: Warning: Unimplemented VCS type.\n' \
                "${FUNCNAME[0]}" \
                >&2
            printf unknown
            return 0
        ;;
        *)
            printf -- \
                '%s: Warning: Unknown VCS type.\n' \
                "${FUNCNAME[0]}" \
                >&2
            printf unknown
            return 0
        ;;
    esac
}

init(){
    # checkout_mode:
    # - snapshot: Build as-is
    # - release: Build the latest tagged release
    # release_tag_pattern: We assume all tags contains dots or underscores release tags
    local \
        checkout_mode \
        flag_dry_run=false \
        flag_force_snapshot=false \
        release_tag_pattern='.*[._].*' \
        snap_version

    for commandline_argument in "${@}"; do
        case "${commandline_argument}" in
            # Enable execution tracing
            --debug)
                set -o xtrace
            ;;
            # Don't run snapcraftctl for testing purpose
            --dry-run)
                flag_dry_run=true
            ;;
            # Force building development snapshot regardless the status of the snap
            --force-snapshot)
                flag_force_snapshot=true
            ;;
            *)
                printf -- \
                    'selective-checkout: Error: Invalid command-line argument.\n' \
                    >&2
                exit 1
            ;;
        esac
    done

    if test "${flag_dry_run}" = false; then
        snapcraftctl pull
    fi

    vcs_check_runtime_dependencies \
        "${PWD}"

    if test "${flag_force_snapshot}" = true; then
        printf -- 'selective-checkout: Force building development snapshots\n' >&2
        checkout_mode=snapshot
    elif test "$(vcs_detect "${PWD}")" = not_found; then
        printf -- 'selective-checkout: Build from source archive\n' >&2
        checkout_mode=snapshot
    elif vcs_is_dirty "${PWD}"; then
        # If tracked files are modified
        # or staging area not empty
        printf -- 'selective-checkout: Working tree is dirty, building development snapshot with additional changes\n' >&2
        checkout_mode=snapshot
    elif ! \
        vcs_has_release_tags \
            "${PWD}" \
            "${release_tag_pattern}"; then
        printf -- \
            'Warning: No release tags found, assuming building from development snapshots.\n' \
            1>&2
        checkout_mode=snapshot
    else
        local \
            all_release_tags \
            last_release_tag \
            last_release_version \
            last_stable_release_on_the_snap_store

        if ! test -v SNAPCRAFT_PROJECT_NAME; then
            printf -- \
                "selective-checkout: Error: This script requires SNAPCRAFT_PROJECT_NAME environment variable set to the snap's identifier.\\n" \
                >&2
            exit 1
        fi

        all_release_tags="$(
            vcs_query_release_tags \
                "${PWD}" \
                "${release_tag_pattern}"
        )"

        last_release_tag="$(
            sort --version-sort <<< "${all_release_tags}" \
                | tail --lines=1
        )"

        # We stripped out the prefix 'v' here
        # TODO: We should make it customizable by command-line option
        # shellcheck disable=SC2001
        last_release_version="$(
            sed 's/^v//' <<< "${last_release_tag}"
        )"

        # Allow the `snap info` command to fail when the snap isn't published to the stable channel
        last_stable_release_on_the_snap_store="$(
            snap info "${SNAPCRAFT_PROJECT_NAME}" || true \
                | awk '$1 == "stable:" { print $2 }' \
                | cut --delimiter=+ --fields=1
        )"

        # If the latest tagged release from the repository has not been
        # released to the stable channel, build that tag instead of the
        # development snapshot and publish it in the edge channel
        if [ "${last_release_version}" != "${last_stable_release_on_the_snap_store}" ]; then
            printf -- \
                "selective-checkout: Last tagged release(%s) hasn't promoted to the stable channel(%s) on the Snap Store, building tagged release instead.\\n" \
                "${last_release_version}" \
                "${last_stable_release_on_the_snap_store}" \
                >&2
            checkout_mode=release
        else
            printf -- 'selective-checkout: Last tagged release is in the stable channel, building development snapshot\n' >&2
            checkout_mode=snapshot
        fi

        unset \
            all_release_tags \
            last_release_version \
            last_stable_release_on_the_snap_store
    fi

    case "${checkout_mode}" in
        snapshot)
            : # do nothing
        ;;
        release)
            vcs_checkout \
                "${PWD}" \
                "${last_release_tag}"
        ;;
        *)
            printf -- 'Error: Invalid checkout_mode selected.\n' >&2
            exit 1
        ;;
    esac

    snap_version="$(
        vcs_describe_revision \
            "${PWD}" \
            | sed s/^v//
    )"

    printf -- 'selective-checkout: Snap version determined to be "%s".\n' \
        "${snap_version}" >&2
    if test "${flag_dry_run}" = false; then
        snapcraftctl \
            set-version \
            "${snap_version}"
    fi

    exit 0
}

init "${@}"
