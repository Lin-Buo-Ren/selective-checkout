#!/usr/bin/env bash
# This scriptlet enhances the pull step that will only build
# development snapshots snaps if the latest tagged release has been
# promoted to the stable channel.  This ensures that there's always
# a revision of the stable release snap available in the edge channel
# for the publisher to promote to stable as currently the build
# infrastructure only supports build on code push (but not new tagged
# releases) at this time.
# https://forum.snapcraft.io/t/selective-checkout-check-out-the-tagged-release-revision-if-it-isnt-promoted-to-the-stable-channel/10617
# 林博仁(Buo-ren, Lin) <Buo.Ren.Lin@gmail.com> © 2018

set \
    -o errexit \
    -o errtrace \
    -o nounset \
    -o pipefail

for required_command in \
    awk \
    cut \
    sed \
    snap \
    sort \
    tail; do
    if ! command -v "${required_command}" >/dev/null; then
        printf -- \
            'Fatal: This script requires the "%s" command in your command search PATHs.\n' \
            "${required_command}" \
            >&2
        exit 1
    fi
done

# Determine which VCS is used
# FIXME: Allow specifying any node under the working directory, not just the root node
vcs_detect(){
    if test $# -ne 1; then
        printf 'FATAL: %s: Parameter quantity mismatch.\n' "${FUNCNAME[0]}" >&2
        exit 1
    fi

    local source_tree_root_dir="${1}"; shift 1

    if test -e "${source_tree_root_dir}"/.git; then
        printf git
    elif test -e "${source_tree_root_dir}"/.hg; then
        printf mercurial
    elif test -e "${source_tree_root_dir}"/.svn; then
        printf subversion
    else
        printf not_found
    fi
}

# Ensure depending software is available before using them
vcs_check_runtime_dependencies(){
    if test $# -ne 1; then
        printf 'FATAL: %s: Parameter quantity mismatch.\n' "${FUNCNAME[0]}" >&2
        exit 1
    fi

    local -r source_tree_root_dir="${1}"; shift 1

    case "$(vcs_detect "${source_tree_root_dir}")" in
        git)
            if ! command -v git &>/dev/null; then
                # Markdown code markup is not Bash tilde expression
                # shellcheck disable=SC2016
                printf -- \
                    '%s: Error: `git` command not found in the command search PATHs.\n' \
                    "${FUNCNAME[0]}" \
                    >&2
                return 1
            fi
        ;;
        mercurial)
            if ! command -v hg &>/dev/null; then
                # Markdown code markup is not Bash tilde expression
                # shellcheck disable=SC2016
                printf -- \
                    '%s: Error: `hg` command not found in the command search PATHs.\n' \
                    "${FUNCNAME[0]}" \
                    >&2
                return 1
            fi
        ;;
        subversion)
            if ! command -v svn &>/dev/null; then
                # Markdown code markup is not Bash tilde expression
                # shellcheck disable=SC2016
                printf -- \
                    '%s: Error: `svn` command not found in the command search PATHs.\n' \
                    "${FUNCNAME[0]}" \
                    >&2
                return 1
            fi
        ;;
        *)
            printf -- \
                '%s: Warning: Unknown VCS type, assuming none.\n' \
                "${FUNCNAME[0]}" \
                >&2
            return 0
        ;;
    esac
}

vcs_is_dirty(){
    if test $# -ne 1; then
        printf 'FATAL: %s: Parameter quantity mismatch.\n' "${FUNCNAME[0]}" >&2
        exit 1
    fi

    local -r source_tree_root_dir="${1}"; shift 1

    case "$(vcs_detect "${source_tree_root_dir}")" in
        git)
            # If tracked files are modified
            # or staging area not empty
            if ! \
                git -C "${source_tree_root_dir}" diff \
                    --quiet \
                || ! \
                git -C "${source_tree_root_dir}"  diff \
                    --staged \
                    --quiet; then
                return 0
            else
                return 1
            fi
        ;;
        mercurial)
            # NOTE:
            # The existence of untracked files is not consider dirty,
            # imitating Git's `--dirty` option of the describe
            # subcommand
            if test -n "$(
                hg --cwd "${source_tree_root_dir}" status \
                    --added \
                    --deleted \
                    --modified \
                    --removed
            )"; then
                return 0
            else
                return 1
            fi
        ;;
        subversion)
            printf -- \
                '%s: Warning: Unimplemented VCS type, assuming dirty.\n' \
                "${FUNCNAME[0]}" \
                >&2
            return 0
        ;;
        *)
            printf -- \
                '%s: Warning: Unknown VCS type, assuming dirty.\n' \
                "${FUNCNAME[0]}" \
                >&2
            return 0
        ;;
    esac
}

vcs_has_release_tags() {
    if test $# -ne 2; then
        printf 'FATAL: %s: Parameter quantity mismatch.\n' "${FUNCNAME[0]}" >&2
        exit 1
    fi

    local -r source_tree_root_dir="${1}"; shift 1

    # Pattern to match a release tag, in extended regular expression(ERE)
    local -r release_tag_pattern="${1}"; shift 1

    case "$(vcs_detect "${source_tree_root_dir}")" in
        git)
            if git -C "${source_tree_root_dir}" tag \
                --list \
                | grep \
                    --extended-regexp \
                    --quiet \
                    "${release_tag_pattern}"; then
                return 0
            else
                return 1
            fi
        ;;
        mercurial)
            if hg --cwd "${source_tree_root_dir}" tags \
                | grep \
                    --extended-regexp \
                    --quiet \
                    "${release_tag_pattern}"; then
                return 0
            else
                return 1
            fi
        ;;
        subversion)
            printf -- \
                '%s: Warning: Unimplemented VCS type, assuming no release tags found.\n' \
                "${FUNCNAME[0]}" \
                >&2
            return 1
        ;;
        *)
            printf -- \
                '%s: Warning: Unknown VCS type, assuming no release tags found.\n' \
                "${FUNCNAME[0]}" \
                >&2
            return 1
        ;;
    esac
}

vcs_query_release_tags(){
    if test $# -ne 2; then
        printf 'FATAL: %s: Parameter quantity mismatch.\n' "${FUNCNAME[0]}" >&2
        exit 1
    fi

    local -r source_tree_root_dir="${1}"; shift 1

    # Pattern to match a release tag, in extended regular expression(ERE)
    local -r release_tag_pattern="${1}"; shift 1

    case "$(vcs_detect "${source_tree_root_dir}")" in
        git)
            if git -C "${source_tree_root_dir}" tag \
                --list \
                | grep \
                    --extended-regexp \
                    "${release_tag_pattern}"; then
                return 0
            else
                return 1
            fi
        ;;
        mercurial)
            if hg --cwd "${source_tree_root_dir}" tags \
                --quiet \
                | grep \
                    --extended-regexp \
                    "${release_tag_pattern}"; then
                return 0
            else
                return 1
            fi
        ;;
        subversion)
            printf -- \
                '%s: Warning: Unimplemented VCS type, assuming no release tags found.\n' \
                "${FUNCNAME[0]}" \
                >&2
            return 1
        ;;
        *)
            printf -- \
                '%s: Warning: Unknown VCS type, assuming no release tags found.\n' \
                "${FUNCNAME[0]}" \
                >&2
            return 1
        ;;
    esac
}

vcs_checkout(){
    if test $# -ne 2; then
        printf 'FATAL: %s: Parameter quantity mismatch.\n' "${FUNCNAME[0]}" >&2
        exit 1
    fi

    local -r source_tree_root_dir="${1}"; shift 1
    local -r revision_to_be_checked_out="${1}"; shift 1

    case "$(vcs_detect "${source_tree_root_dir}")" in
        git)
            git -C "${source_tree_root_dir}" checkout \
                "${revision_to_be_checked_out}"
            return 0
        ;;
        mercurial)
            hg --cwd "${source_tree_root_dir}" checkout \
                --rev "${revision_to_be_checked_out}"
            return 0
        ;;
        subversion)
            printf -- \
                '%s: Warning: Unimplemented VCS type, not doing anything.\n' \
                "${FUNCNAME[0]}" \
                >&2
            return 1
        ;;
        *)
            printf -- \
                '%s: Warning: Unknown VCS type, not doing anything.\n' \
                "${FUNCNAME[0]}" \
                >&2
            return 1
        ;;
    esac
}

# Describe software version, use tags when available
vcs_describe_version(){
    if test $# -ne 1; then
        printf 'FATAL: %s: Parameter quantity mismatch.\n' "${FUNCNAME[0]}" >&2
        exit 1
    fi

    local -r source_tree_root_dir="${1}"; shift 1

    case "$(vcs_detect "${source_tree_root_dir}")" in
        git)
            git describe \
                --always \
                --dirty \
                --tags
            return 0
        ;;
        mercurial)
            hg --cwd "${source_tree_root_dir}" log \
                --rev . \
                --template "{latesttag}{sub('^-0-.*', '', '-{latesttagdistance}-m{shortest(node, 7)}')}"
            return 0
        ;;
        subversion)
            printf -- \
                '%s: Warning: Unimplemented VCS type.\n' \
                "${FUNCNAME[0]}" \
                >&2
            printf unknown
            return 0
        ;;
        *)
            printf -- \
                '%s: Warning: Unknown VCS type.\n' \
                "${FUNCNAME[0]}" \
                >&2
            printf unknown
            return 0
        ;;
    esac
}

# Describe version control revision, only revision identifier/hash with
# customizable minimum length
# FIXME: Some node among source tree should be enough for source_tree_root_dir
vcs_describe_revision(){
    if test $# -ne 3; then
        printf 'FATAL: %s: Parameter quantity mismatch.\n' "${FUNCNAME[0]}" >&2
        exit 1
    fi

    local -r source_tree_root_dir="${1}"; shift 1
    local -r revision_identifier_length_minimum="${1}"; shift 1
    local -r dirty_postfix="${1}"; shift 1

    case "$(vcs_detect "${source_tree_root_dir}")" in
        git)
            if ! git -C "${source_tree_root_dir}" describe --always >/dev/null; then
                printf unknown
            else
                git -C "${source_tree_root_dir}" describe \
                    --abbrev="${revision_identifier_length_minimum}" \
                    --always \
                    --dirty="${dirty_postfix}" \
                    --match=nothing
            fi
            return 0
        ;;
        mercurial)
            if ! hg --cwd "${source_tree_root_dir}" status >/dev/null; then
                printf unknown
            else
                # FIXME: Is there a better way of generating this only using Mercurial?
                local hg_revision

                hg_revision+="$(
                    hg --cwd "${source_tree_root_dir}" log \
                        --rev . \
                        --template "{shortest(node, ${revision_identifier_length_minimum})}"
                )"

                if vcs_is_dirty "${source_tree_root_dir}"; then
                    hg_revision+="${dirty_postfix}"
                fi

                printf -- %s "${hg_revision}"
            fi
            return 0
        ;;
        subversion)
            printf -- \
                '%s: Warning: Unimplemented VCS type.\n' \
                "${FUNCNAME[0]}" \
                >&2
            printf unknown
            return 0
        ;;
        *)
            printf -- \
                '%s: Warning: Unknown VCS type.\n' \
                "${FUNCNAME[0]}" \
                >&2
            printf unknown
            return 0
        ;;
    esac
}

init(){
    # checkout_mode:
    # - snapshot: Build as-is
    # - release: Build the latest tagged release
    # release_tag_pattern: We assume all tags contains dots or underscores release tags
    local \
        checkout_mode \
        flag_append_packaging_version=false \
        flag_dry_run=false \
        flag_debug_tracing=false \
        flag_force_snapshot=false \
        packaging_revision \
        release_tag_pattern='.*[._].*' \
        release_tag_prefix=v \
        snap_version \
        snap_version_postfix_seperator=+ \
        upstream_version

    while true; do
        if test "${#}" -eq 0; then
            break
        else
            case "${1}" in
                # Append packaging revision after snap version
                --append-packaging-revision)
                    flag_append_packaging_version=true
                ;;
                # Enable execution tracing
                --debug)
                    flag_debug_tracing=true
                ;;
                # Don't run snapcraftctl for testing purpose
                --dry-run)
                    flag_dry_run=true
                ;;
                # Force building development snapshot regardless the status of the snap
                --force-snapshot)
                    flag_force_snapshot=true
                ;;
                # Set the prefix for all release tags(default: `v`), the prefix will be stripped from snap version string
                --release-tag-prefix*)
                    if test "${1}" != --release-tag-prefix; then
                        release_tag_prefix="$(
                            cut \
                                --delimiter== \
                                --fields=2 \
                                <<< "${1}"
                        )"
                    else
                        if "${#}" -eq 0; then
                            printf -- \
                                'selective-checkout: Error: --release-tag-prefix requires one argument.\n' \
                                >&2
                            exit 1
                        fi
                        release_tag_prefix="${2}"
                        shift 1
                    fi
                ;;
                # Set the seperator for the postfixed string in the snap version string
                # the postfixed string will be stripped before comparing with the stripped
                # uptream release version
                --snap-postfix-seperator*)
                    if test "${1}" != --snap-postfix-seperator; then
                        snap_version_postfix_seperator="$(
                            cut \
                                --delimiter== \
                                --fields=2 \
                                <<< "${1}"
                        )"
                    else
                        if "${#}" -eq 0; then
                            printf -- \
                                'selective-checkout: Error: --snap-postfix-seperator requires one argument.\n' \
                                >&2
                            exit 1
                        fi
                        snap_version_postfix_seperator="${2}"
                        shift 1
                    fi
                ;;
                *)
                    printf -- \
                        'selective-checkout: Error: Invalid command-line argument.\n' \
                        >&2
                    exit 1
                ;;
            esac
            shift 1
        fi
    done

    if test "${flag_debug_tracing}" = true; then
        set -o xtrace
    fi

    vcs_check_runtime_dependencies \
        "${PWD}"

    if test "${flag_force_snapshot}" = true; then
        printf -- 'selective-checkout: Force building development snapshots\n' >&2
        checkout_mode=snapshot
    elif test "$(vcs_detect "${PWD}")" = not_found; then
        printf -- 'selective-checkout: Build from source archive\n' >&2
        checkout_mode=snapshot
    elif vcs_is_dirty "${PWD}"; then
        # If tracked files are modified
        # or staging area not empty
        printf -- 'selective-checkout: Working tree is dirty, building development snapshot with additional changes\n' >&2
        checkout_mode=snapshot
    elif ! \
        vcs_has_release_tags \
            "${PWD}" \
            "${release_tag_pattern}"; then
        printf -- \
            'Warning: No release tags found, assuming building from development snapshots.\n' \
            1>&2
        checkout_mode=snapshot
    else
        local \
            all_release_tags \
            last_release_tag \
            last_release_version \
            last_release_version_on_the_snap_store

        if ! test -v SNAPCRAFT_PROJECT_NAME; then
            printf -- \
                "selective-checkout: Error: This script requires SNAPCRAFT_PROJECT_NAME environment variable set to the snap's identifier.\\n" \
                >&2
            exit 1
        fi

        all_release_tags="$(
            vcs_query_release_tags \
                "${PWD}" \
                "${release_tag_pattern}"
        )"

        last_release_tag="$(
            sort --version-sort <<< "${all_release_tags}" \
                | tail --lines=1
        )"

        # shellcheck disable=SC2001
        last_release_version="$(
            sed "s#^${release_tag_prefix}##" <<< "${last_release_tag}" \
                | tr _ .
        )"

        # Allow the `snap info` command to fail when the snap isn't published to the stable channel
        last_release_version_on_the_snap_store="$(
            snap info "${SNAPCRAFT_PROJECT_NAME}" \
                | awk '$1 == "stable:" { print $2 }' \
                | cut --delimiter="${snap_version_postfix_seperator}" --fields=1 \
                || true
        )"

        # If the latest tagged release from the repository has not been
        # released to the stable channel, build that tag instead of the
        # development snapshot and publish it in the edge channel
        if [ "${last_release_version}" != "${last_release_version_on_the_snap_store}" ]; then
            printf -- \
                "selective-checkout: Last tagged release(%s) hasn't promoted to the stable channel(%s) on the Snap Store, building tagged release instead.\\n" \
                "${last_release_version}" \
                "${last_release_version_on_the_snap_store}" \
                >&2
            checkout_mode=release
        else
            printf -- 'selective-checkout: Last tagged release is in the stable channel, building development snapshot\n' >&2
            checkout_mode=snapshot
        fi

        unset \
            all_release_tags \
            last_release_version \
            last_release_version_on_the_snap_store
    fi

    case "${checkout_mode}" in
        snapshot)
            : # do nothing
        ;;
        release)
            vcs_checkout \
                "${PWD}" \
                "${last_release_tag}"
        ;;
        *)
            printf -- 'Error: Invalid checkout_mode selected.\n' >&2
            exit 1
        ;;
    esac

    upstream_version="$(
        vcs_describe_version \
            "${PWD}" \
            | sed "s#^${release_tag_prefix}##"
    )"

    if test "${flag_append_packaging_version}" = true; then
        # WORKAROUND:
        #   Allow fetching project revision in multipass build
        #   environment, which uses out-of-tree build and packaging
        #   source tree repo location can't be determined via environment
        #   Unable to determine project version info in multipass build environment - snapcraft - snapcraft.io
        #   https://forum.snapcraft.io/t/unable-to-determine-project-version-info-in-multipass-build-environment/10416
        if test -d /root/project; then
            packaging_source_tree_root_dir=/root/project
        else
            # parts/_part_name_/src
            packaging_source_tree_root_dir=../../..
        fi

        packaging_revision="$(
            vcs_describe_revision \
                "${packaging_source_tree_root_dir}" \
                4 \
                -d
        )"
        snap_version="${upstream_version}+pkg-${packaging_revision}"
    else
        snap_version="${upstream_version}"
    fi

    printf -- 'selective-checkout: Snap version determined to be "%s".\n' \
        "${snap_version}" >&2
    if test "${flag_dry_run}" = false; then
        snapcraftctl \
            set-version \
            "${snap_version}"
    fi

    exit 0
}

init "${@}"
