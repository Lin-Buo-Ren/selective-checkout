#!/usr/bin/env bash
# This scriptlet enhances the pull step that will only build
# development snapshots snaps if the latest tagged release has been
# promoted to the stable channel.  This ensures that there's always
# a revision of the stable release snap available in the edge channel
# for the publisher to promote to stable as currently the build
# infrastructure only supports build on code push (but not new tagged
# releases) at this time.
# https://forum.snapcraft.io/t/selective-checkout-check-out-the-tagged-release-revision-if-it-isnt-promoted-to-the-stable-channel/10617
# 林博仁(Buo-ren, Lin) <Buo.Ren.Lin@gmail.com> © 2018

set \
    -o errexit \
    -o errtrace \
    -o nounset \
    -o pipefail

for required_command in \
    awk \
    cut \
    sed \
    snap \
    sort \
    tail \
    tr; do
    if ! command -v "${required_command}" >/dev/null; then
        printf -- \
            'Fatal: This script requires the "%s" command in your command search PATHs.\n' \
            "${required_command}" \
            >&2
        exit 1
    fi
done

init(){
    # checkout_mode:
    # - snapshot: Build as-is
    # - release: Build the latest tagged release
    # tag_pattern_release: We assume all tags contains dots or underscores release tags
    local \
        checkout_mode \
        flag_append_packaging_version=false \
        flag_dry_run=false \
        flag_debug_tracing=false \
        flag_force_snapshot=false \
        packaging_revision \
        postfix_dirty_marker_packaging=-d \
        postfix_dirty_marker_upstream=-dirty \
        tag_pattern_beta='-beta[[:digit:]]+$' \
        tag_pattern_release='.*[._].*' \
        tag_pattern_release_candidate='-rc[[:digit:]]+$' \
        tag_prefix_release=v \
        revision_minimal_length_packaging=4 \
        revision_minimal_length_upstream=7 \
        snap_version \
        snap_version_postfix_seperator=+ \
        upstream_version

    while true; do
        if test "${#}" -eq 0; then
            break
        else
            case "${1}" in
                # Append packaging revision after snap version
                --append-packaging-revision)
                    flag_append_packaging_version=true
                ;;
                # Enable execution tracing
                --debug)
                    flag_debug_tracing=true
                ;;
                # Don't run snapcraftctl for testing purpose
                --dry-run)
                    flag_dry_run=true
                ;;
                # Force building development snapshot regardless the status of the snap
                --force-snapshot)
                    flag_force_snapshot=true
                ;;
                --packaging-dirty-marker-postfix*)
                    if test "${1}" != --packaging-dirty-marker-postfix; then
                        postfix_dirty_marker_packaging="$(
                            cut \
                                --delimiter== \
                                --fields=2 \
                                <<< "${1}"
                        )"
                    else
                        if "${#}" -eq 0; then
                            printf -- \
                                'selective-checkout: Error: --packaging-dirty-marker-postfix requires one argument.\n' \
                                >&2
                            exit 1
                        fi
                        postfix_dirty_marker_packaging="${2}"
                        shift 1
                    fi
                ;;
                --packaging-revision-minimal-length*)
                    if test "${1}" != --packaging-revision-minimal-length; then
                        revision_minimal_length_packaging="$(
                            cut \
                                --delimiter== \
                                --fields=2 \
                                <<< "${1}"
                        )"
                    else
                        if "${#}" -eq 0; then
                            printf -- \
                                'selective-checkout: Error: --packaging-revision-minimal-length requires one argument.\n' \
                                >&2
                            exit 1
                        fi
                        revision_minimal_length_packaging="${2}"
                        shift 1
                    fi
                ;;
                # Set the prefix for all release tags(default: `v`), the prefix will be stripped from snap version string
                --release-tag-prefix*)
                    if test "${1}" != --release-tag-prefix; then
                        tag_prefix_release="$(
                            cut \
                                --delimiter== \
                                --fields=2 \
                                <<< "${1}"
                        )"
                    else
                        if "${#}" -eq 0; then
                            printf -- \
                                'selective-checkout: Error: --release-tag-prefix requires one argument.\n' \
                                >&2
                            exit 1
                        fi
                        tag_prefix_release="${2}"
                        shift 1
                    fi
                ;;
                --upstream-dirty-marker-postfix*)
                    if test "${1}" != --upstream-dirty-marker-postfix; then
                        postfix_dirty_marker_upstream="$(
                            cut \
                                --delimiter== \
                                --fields=2 \
                                <<< "${1}"
                        )"
                    else
                        if "${#}" -eq 0; then
                            printf -- \
                                'selective-checkout: Error: --upstream-dirty-marker-postfix requires one argument.\n' \
                                >&2
                            exit 1
                        fi
                        postfix_dirty_marker_upstream="${2}"
                        shift 1
                    fi
                ;;
                --upstream-revision-minimal-length*)
                    if test "${1}" != --upstream-revision-minimal-length; then
                        revision_minimal_length_upstream="$(
                            cut \
                                --delimiter== \
                                --fields=2 \
                                <<< "${1}"
                        )"
                    else
                        if "${#}" -eq 0; then
                            printf -- \
                                'selective-checkout: Error: --upstream-revision-minimal-length requires one argument.\n' \
                                >&2
                            exit 1
                        fi
                        revision_minimal_length_upstream="${2}"
                        shift 1
                    fi
                ;;
                # Set the seperator for the postfixed string in the snap version string
                # the postfixed string will be stripped before comparing with the stripped
                # uptream release version
                --snap-postfix-seperator*)
                    if test "${1}" != --snap-postfix-seperator; then
                        snap_version_postfix_seperator="$(
                            cut \
                                --delimiter== \
                                --fields=2 \
                                <<< "${1}"
                        )"
                    else
                        if "${#}" -eq 0; then
                            printf -- \
                                'selective-checkout: Error: --snap-postfix-seperator requires one argument.\n' \
                                >&2
                            exit 1
                        fi
                        snap_version_postfix_seperator="${2}"
                        shift 1
                    fi
                ;;
                *)
                    printf -- \
                        'selective-checkout: Error: Invalid command-line argument.\n' \
                        >&2
                    exit 1
                ;;
            esac
            shift 1
        fi
    done

    if test "${flag_debug_tracing}" = true; then
        set -o xtrace
    fi

    vcs_check_runtime_dependencies \
        "${PWD}"

    if test "${flag_force_snapshot}" = true; then
        printf -- 'selective-checkout: Force building development snapshots\n' >&2
        checkout_mode=snapshot
    elif test "$(vcs_detect "${PWD}")" = not_found; then
        printf -- 'selective-checkout: Build from source archive\n' >&2
        checkout_mode=snapshot
    elif vcs_is_dirty "${PWD}"; then
        # If tracked files are modified
        # or staging area not empty
        printf -- 'selective-checkout: Working tree is dirty, building development snapshot with additional changes\n' >&2
        checkout_mode=snapshot
    elif ! \
        vcs_has_release_tags \
            "${PWD}" \
            "${tag_pattern_release}"; then
        printf -- \
            'Warning: No release tags found, assuming building from development snapshots.\n' \
            1>&2
        checkout_mode=snapshot
    else
        local \
            all_release_tags \
            last_release_tag \
            last_release_version \
            last_release_version_on_the_snap_store \
            normalized_release_version

        local -A map_of_normalized_version_to_tag

        if ! test -v SNAPCRAFT_PROJECT_NAME; then
            printf -- \
                "selective-checkout: Error: This script requires SNAPCRAFT_PROJECT_NAME environment variable set to the snap's identifier.\\n" \
                >&2
            exit 1
        fi

        all_release_tags="$(
            vcs_query_release_tags \
                "${PWD}" \
                "${tag_pattern_release}"
        )"

        for tag in ${all_release_tags}; do
            normalized_release_version="$(
                tr _ . <<< "${tag}" \
                    | sed "s#^${tag_prefix_release}##"
            )"

            map_of_normalized_version_to_tag[${normalized_release_version}]="${tag}"
        done

        last_release_version="$(
            echo -n "${!map_of_normalized_version_to_tag[@]}" \
                | tr ' ' "\\n" \
                | sort --version-sort \
                | tail --lines=1
        )"

        last_release_tag="${map_of_normalized_version_to_tag[${last_release_version}]}"

        # Allow the `snap info` command to fail when the snap isn't published to the stable channel
        last_release_version_on_the_snap_store="$(
            snap info "${SNAPCRAFT_PROJECT_NAME}" \
                | awk '$1 == "stable:" { print $2 }' \
                | cut --delimiter="${snap_version_postfix_seperator}" --fields=1 \
                || true
        )"

        # If the latest tagged release from the repository has not been
        # released to the stable channel, build that tag instead of the
        # development snapshot and publish it in the edge channel
        if [ "${last_release_version}" != "${last_release_version_on_the_snap_store}" ]; then
            printf -- \
                "selective-checkout: Last tagged release(%s) hasn't promoted to the stable channel(%s) on the Snap Store, building tagged release instead.\\n" \
                "${last_release_version}" \
                "${last_release_version_on_the_snap_store}" \
                >&2
            checkout_mode=release
        else
            printf -- 'selective-checkout: Last tagged release(%s) is in the stable channel, building development snapshot\n' \
                "${last_release_version}" \
                >&2
            checkout_mode=snapshot
        fi

        unset \
            all_release_tags \
            last_release_version \
            last_release_version_on_the_snap_store
    fi

    case "${checkout_mode}" in
        snapshot)
            : # do nothing
        ;;
        release)
            vcs_checkout_tag \
                "${PWD}" \
                "${last_release_tag}"
        ;;
        *)
            printf -- 'Error: Invalid checkout_mode selected.\n' >&2
            exit 1
        ;;
    esac

    upstream_version="$(
        vcs_describe_version \
            "${PWD}" \
            "${revision_minimal_length_upstream}" \
            "${postfix_dirty_marker_upstream}" \
            | sed "s#^${tag_prefix_release}##"
    )"

    if test "${flag_append_packaging_version}" = true; then
        # WORKAROUND:
        #   Allow fetching project revision in multipass build
        #   environment, which uses out-of-tree build and packaging
        #   source tree repo location can't be determined via environment
        #   Unable to determine project version info in multipass build environment - snapcraft - snapcraft.io
        #   https://forum.snapcraft.io/t/unable-to-determine-project-version-info-in-multipass-build-environment/10416
        if test -d /root/project; then
            packaging_source_tree_root_dir=/root/project
        else
            # parts/_part_name_/src
            packaging_source_tree_root_dir=../../..
        fi

        packaging_revision="$(
            vcs_describe_revision \
                "${packaging_source_tree_root_dir}" \
                "${revision_minimal_length_packaging}" \
                "${postfix_dirty_marker_packaging}"
        )"
        snap_version="${upstream_version}+pkg-${packaging_revision}"
    else
        snap_version="${upstream_version}"
    fi

    printf -- 'selective-checkout: Snap version determined to be "%s".\n' \
        "${snap_version}" >&2
    if test "${flag_dry_run}" = false; then
        snapcraftctl \
            set-version \
            "${snap_version}"
    fi

    exit 0
}

# Determine which VCS is used
# FIXME: Allow specifying any node under the working directory, not just the root node
vcs_detect(){
    if test $# -ne 1; then
        printf 'FATAL: %s: Parameter quantity mismatch.\n' "${FUNCNAME[0]}" >&2
        exit 1
    fi

    local source_tree_root_dir="${1}"; shift 1

    if test -e "${source_tree_root_dir}"/.git; then
        printf git
    elif test -e "${source_tree_root_dir}"/.hg; then
        printf mercurial
    elif test -e "${source_tree_root_dir}"/.svn; then
        printf subversion
    else
        printf not_found
    fi
}

# Ensure depending software is available before using them
vcs_check_runtime_dependencies(){
    if test $# -ne 1; then
        printf 'FATAL: %s: Parameter quantity mismatch.\n' "${FUNCNAME[0]}" >&2
        exit 1
    fi

    local -r source_tree_root_dir="${1}"; shift 1

    case "$(vcs_detect "${source_tree_root_dir}")" in
        git)
            if ! command -v git &>/dev/null; then
                # Markdown code markup is not Bash tilde expression
                # shellcheck disable=SC2016
                printf -- \
                    '%s: Error: `git` command not found in the command search PATHs.\n' \
                    "${FUNCNAME[0]}" \
                    >&2
                return 1
            fi
        ;;
        mercurial)
            if ! command -v hg &>/dev/null; then
                # Markdown code markup is not Bash tilde expression
                # shellcheck disable=SC2016
                printf -- \
                    '%s: Error: `hg` command not found in the command search PATHs.\n' \
                    "${FUNCNAME[0]}" \
                    >&2
                return 1
            fi
        ;;
        subversion)
            if ! command -v svn &>/dev/null; then
                # Markdown code markup is not Bash tilde expression
                # shellcheck disable=SC2016
                printf -- \
                    '%s: Error: `svn` command not found in the command search PATHs.\n' \
                    "${FUNCNAME[0]}" \
                    >&2
                return 1
            fi
        ;;
        *)
            printf -- \
                '%s: Warning: Unknown VCS type, assuming none.\n' \
                "${FUNCNAME[0]}" \
                >&2
            return 0
        ;;
    esac
}

vcs_is_dirty(){
    if test $# -ne 1; then
        printf 'FATAL: %s: Parameter quantity mismatch.\n' "${FUNCNAME[0]}" >&2
        exit 1
    fi

    local -r source_tree_root_dir="${1}"; shift 1

    case "$(vcs_detect "${source_tree_root_dir}")" in
        git)
            # If tracked files are modified
            # or staging area not empty
            if ! \
                git -C "${source_tree_root_dir}" diff \
                    --quiet \
                || ! \
                git -C "${source_tree_root_dir}"  diff \
                    --staged \
                    --quiet; then
                return 0
            else
                return 1
            fi
        ;;
        mercurial)
            # NOTE:
            # The existence of untracked files is not consider dirty,
            # imitating Git's `--dirty` option of the describe
            # subcommand
            if test -n "$(
                hg --cwd "${source_tree_root_dir}" status \
                    --added \
                    --deleted \
                    --modified \
                    --removed
            )"; then
                return 0
            else
                return 1
            fi
        ;;
        subversion)
            # NOTE: Is there any straightforward way to check this?
            if test -n "$(
                svn status -q
            )"; then
                return 0
            else
                return 1
            fi
        ;;
        *)
            printf -- \
                '%s: Warning: Unknown VCS type, assuming dirty.\n' \
                "${FUNCNAME[0]}" \
                >&2
            return 0
        ;;
    esac
}

vcs_has_release_tags() {
    if test $# -ne 2; then
        printf 'FATAL: %s: Parameter quantity mismatch.\n' "${FUNCNAME[0]}" >&2
        exit 1
    fi

    local -r source_tree_root_dir="${1}"; shift 1

    # Pattern to match a release tag, in extended regular expression(ERE)
    local -r tag_pattern_release="${1}"; shift 1

    case "$(vcs_detect "${source_tree_root_dir}")" in
        git)
            if git -C "${source_tree_root_dir}" tag \
                --list \
                | grep \
                    --extended-regexp \
                    --quiet \
                    -- \
                    "${tag_pattern_release}"; then
                return 0
            else
                return 1
            fi
        ;;
        mercurial)
            if hg --cwd "${source_tree_root_dir}" tags \
                | grep \
                    --extended-regexp \
                    --quiet \
                    -- \
                    "${tag_pattern_release}"; then
                return 0
            else
                return 1
            fi
        ;;
        subversion)
            local \
                source_tree_root_url \
                tags_dir_url

            source_tree_root_url="$(
                svn info \
                    --show-item url \
                     "${source_tree_root_dir}"
            )"

            # Supported source URLs:
            # * /trunk
            # * /tags/_tag_name_
            case "${source_tree_root_url}" in
                */trunk)
                    # Strip trailing shortest matched pattern
                    # https://www.gnu.org/software/bash/manual/html_node/Shell-Parameter-Expansion.html
                    tags_dir_url="${source_tree_root_url%/trunk}/tags"
                ;;
                */tags/*)
                    tags_dir_url="${source_tree_root_url%/*}"
                ;;
                *)
                    printf -- \
                        'Warning: %s: Unsupported SVN source URL, assuming no release tags found.\n' \
                        "${FUNCNAME[0]}" \
                        >&2
                    return 1
                ;;
            esac

            if svn list \
                "${tags_dir_url}" \
                | sed 's#/$##' \
                | grep \
                    --extended-regexp \
                    --quiet \
                    -- \
                    "${tag_pattern_release}"; then
                return 0
            else
                return 1
            fi
        ;;
        *)
            printf -- \
                '%s: Warning: Unknown VCS type, assuming no release tags found.\n' \
                "${FUNCNAME[0]}" \
                >&2
            return 1
        ;;
    esac
}

vcs_query_release_tags(){
    if test $# -ne 2; then
        printf 'FATAL: %s: Parameter quantity mismatch.\n' "${FUNCNAME[0]}" >&2
        exit 1
    fi

    local -r source_tree_root_dir="${1}"; shift 1

    # Pattern to match a release tag, in extended regular expression(ERE)
    local -r tag_pattern_release="${1}"; shift 1

    case "$(vcs_detect "${source_tree_root_dir}")" in
        git)
            if git -C "${source_tree_root_dir}" tag \
                --list \
                | grep \
                    --extended-regexp \
                    -- \
                    "${tag_pattern_release}"; then
                return 0
            else
                return 1
            fi
        ;;
        mercurial)
            if hg --cwd "${source_tree_root_dir}" tags \
                --quiet \
                | grep \
                    --extended-regexp \
                    -- \
                    "${tag_pattern_release}"; then
                return 0
            else
                return 1
            fi
        ;;
        subversion)
            local \
                source_tree_root_url \
                tags_dir_url

            source_tree_root_url="$(
                svn info \
                    --show-item url \
                     "${source_tree_root_dir}"
            )"

            # Supported source URLs:
            # * /trunk
            # * /tags/_tag_name_
            case "${source_tree_root_url}" in
                */trunk)
                    # Strip trailing shortest matched pattern
                    # https://www.gnu.org/software/bash/manual/html_node/Shell-Parameter-Expansion.html
                    tags_dir_url="${source_tree_root_url%/trunk}/tags"
                ;;
                */tags/*)
                    tags_dir_url="${source_tree_root_url%/*}"
                ;;
                *)
                    printf -- \
                        'Warning: %s: Unsupported SVN source URL, assuming no release tags found.\n' \
                        "${FUNCNAME[0]}" \
                        >&2
                    return 1
                ;;
            esac

            if svn list \
                "${tags_dir_url}" \
                | sed 's#/$##' \
                | grep \
                    --extended-regexp \
                    -- \
                    "${tag_pattern_release}"; then
                return 0
            else
                return 1
            fi
        ;;
        *)
            printf -- \
                '%s: Warning: Unknown VCS type, assuming no release tags found.\n' \
                "${FUNCNAME[0]}" \
                >&2
            return 1
        ;;
    esac
}

vcs_checkout_tag(){
    if test $# -ne 2; then
        printf 'FATAL: %s: Parameter quantity mismatch.\n' "${FUNCNAME[0]}" >&2
        exit 1
    fi

    local -r source_tree_root_dir="${1}"; shift 1
    local -r tag_to_be_checked_out="${1}"; shift 1

    case "$(vcs_detect "${source_tree_root_dir}")" in
        git)
            git -C "${source_tree_root_dir}" checkout \
                "${tag_to_be_checked_out}"
            return 0
        ;;
        mercurial)
            hg --cwd "${source_tree_root_dir}" checkout \
                --rev "${tag_to_be_checked_out}"
            return 0
        ;;
        subversion)
            local \
                source_tree_root_url \
                tags_dir_url

            source_tree_root_url="$(
                svn info \
                    --show-item url \
                     "${source_tree_root_dir}"
            )"

            # Supported source URLs:
            # * /trunk
            # * /tags/_tag_name_
            case "${source_tree_root_url}" in
                */trunk)
                    # Strip trailing shortest matched pattern
                    # https://www.gnu.org/software/bash/manual/html_node/Shell-Parameter-Expansion.html
                    tags_dir_url="${source_tree_root_url%/trunk}/tags"
                ;;
                */tags/*)
                    tags_dir_url="${source_tree_root_url%/*}"
                ;;
                *)
                    printf -- \
                        'Warning: %s: Unsupported SVN source URL, assuming check out failed.\n' \
                        "${FUNCNAME[0]}" \
                        >&2
                    return 1
                ;;
            esac

            if svn checkout \
                "${tags_dir_url}"/"${tag_to_be_checked_out}"; then
                return 0
            else
                return 1
            fi
        ;;
        *)
            printf -- \
                '%s: Warning: Unknown VCS type, not doing anything.\n' \
                "${FUNCNAME[0]}" \
                >&2
            return 1
        ;;
    esac
}

# Describe software version, use tags when available
vcs_describe_version(){
    if test $# -ne 3; then
        printf 'FATAL: %s: Parameter quantity mismatch.\n' "${FUNCNAME[0]}" >&2
        exit 1
    fi

    local -r source_tree_root_dir="${1}"; shift 1
    local -r revision_identifier_length_minimum="${1}"; shift 1
    local -r dirty_postfix="${1}"; shift 1

    case "$(vcs_detect "${source_tree_root_dir}")" in
        git)
            git describe \
                --abbrev="${revision_identifier_length_minimum}" \
                --always \
                --dirty="${dirty_postfix}" \
                --tags
            return 0
        ;;
        mercurial)
            hg --cwd "${source_tree_root_dir}" log \
                --rev . \
                --template "{latesttag}{sub('^-0-.*', '', '-{latesttagdistance}-m{shortest(node, ${revision_identifier_length_minimum})}')}"
            if vcs_is_dirty "${source_tree_root_dir}"; then
                printf -- %s "${dirty_postfix}"
            fi
            return 0
        ;;
        subversion)
            local \
                source_tree_root_url

            source_tree_root_url="$(
                svn info \
                    --show-item url \
                     "${source_tree_root_dir}"
            )"

            # Supported source URLs:
            # * /trunk
            # * /tags/_tag_name_
            case "${source_tree_root_url}" in
                */trunk)
                    printf %s \
                        "rev$(
                            svn info \
                                --show-item revision \
                                "${source_tree_root_dir}"
                        )"
                ;;
                */tags/*)
                    local tag
                    tag="${source_tree_root_url##*/}"
                    printf %s "${tag}"
                ;;
                *)
                    printf -- \
                        'Warning: %s: Unsupported SVN source URL.\n' \
                        "${FUNCNAME[0]}" \
                        >&2
                    printf unknown
                    return 1
                ;;
            esac

            if vcs_is_dirty "${source_tree_root_dir}"; then
                printf -- %s "${dirty_postfix}"
            fi
        ;;
        *)
            printf -- \
                '%s: Warning: Unknown VCS type.\n' \
                "${FUNCNAME[0]}" \
                >&2
            printf unknown
            return 0
        ;;
    esac
}

# Describe version control revision, only revision identifier/hash with
# customizable minimum length
# FIXME: Some node among source tree should be enough for source_tree_root_dir
vcs_describe_revision(){
    if test $# -ne 3; then
        printf 'FATAL: %s: Parameter quantity mismatch.\n' "${FUNCNAME[0]}" >&2
        exit 1
    fi

    local -r source_tree_root_dir="${1}"; shift 1
    local -r revision_identifier_length_minimum="${1}"; shift 1
    local -r dirty_postfix="${1}"; shift 1

    case "$(vcs_detect "${source_tree_root_dir}")" in
        git)
            if ! git -C "${source_tree_root_dir}" describe --always >/dev/null; then
                printf unknown
            else
                git -C "${source_tree_root_dir}" describe \
                    --abbrev="${revision_identifier_length_minimum}" \
                    --always \
                    --dirty="${dirty_postfix}" \
                    --match=nothing
            fi
            return 0
        ;;
        mercurial)
            if ! hg --cwd "${source_tree_root_dir}" status >/dev/null; then
                printf unknown
            else
                # FIXME: Is there a better way of generating this only using Mercurial?
                local hg_revision

                hg_revision+="$(
                    hg --cwd "${source_tree_root_dir}" log \
                        --rev . \
                        --template "{shortest(node, ${revision_identifier_length_minimum})}"
                )"

                if vcs_is_dirty "${source_tree_root_dir}"; then
                    hg_revision+="${dirty_postfix}"
                fi

                printf -- %s "${hg_revision}"
            fi
            return 0
        ;;
        subversion)
            svn info \
                --show-item revision \
                    "${source_tree_root_dir}"

            if vcs_is_dirty "${source_tree_root_dir}"; then
                printf -- %s "${dirty_postfix}"
            fi
        ;;
        *)
            printf -- \
                '%s: Warning: Unknown VCS type.\n' \
                "${FUNCNAME[0]}" \
                >&2
            printf unknown
            return 0
        ;;
    esac
}

init "${@}"
